
#include <wordring/string/atom.hpp>
#include <wordring/trie/trie.hpp>
#include <wordring/whatwg/infra/unicode.hpp>

#include <boost/algorithm/string.hpp>

#include <algorithm>
#include <array>
#include <filesystem>
#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <type_traits>
#include <unordered_map>

#define STRING(str) #str
#define TO_STRING(str) STRING(str)

std::filesystem::path data_path{ TO_STRING(DATA_PATH) };
std::filesystem::path atom_hpp_path{ TO_STRING(ATOM_HPP_PATH) };
std::filesystem::path atom_defs_hpp_path{ TO_STRING(ATOM_DEFS_HPP_PATH) };
std::filesystem::path atom_cpp_path{ TO_STRING(ATOM_CPP_PATH) };

/*
引数で指定されたファイルを読み込み、行で分割して配列として返す

テンプレート引数　Container 配列の配列が渡された場合、行をさらにタブ基準で分割し、格納する
*/
template <typename Container = std::vector<std::u32string>>
Container read(std::filesystem::path const& path)
{
	using namespace wordring::whatwg;

	Container result;

	auto in = std::ifstream(path);
	assert(!in.fail());

	std::vector<std::u32string> buf;
	std::string line;
	while (std::getline(in, line))
	{
		boost::algorithm::trim(line);
		if (line.empty()) continue;
		buf.push_back(encoding_cast<std::u32string>(line));
	}

	if constexpr (std::is_same_v<Container, std::vector<std::u32string>>)
	{
		std::sort(buf.begin(), buf.end());
		buf.erase(std::unique(buf.begin(), buf.end()), buf.end());
		return buf;
	}
	else
	{
		for (std::u32string const& s : buf)
		{
			std::vector<std::u32string> tmp;
			boost::algorithm::split(tmp, s, boost::is_any_of(U"\t"));
			typename Container::value_type a;
			assert(tmp.size() <= a.size());
			for (std::uint32_t i = 0; i < tmp.size(); ++i) a[i] = tmp[i];
			result.push_back(a);
		}
	}

	return result;
}

int main()
{
	using namespace wordring;

	// HTML タグ
	auto elements = read(data_path / "elements.txt");
	// HTML 属性
	auto attributes = read(data_path / "attributes.txt");
	// HTML イベント
	auto events = read(data_path / "events.txt");

	// SVG 属性 [ token_attr, element_attr ]
	auto svg_attributes = read<std::vector<std::array<std::u32string, 2>>>(data_path / "svg_attributes.txt");
	// MathML属性名
	auto mathml_attributes = read(data_path / "mathml_attributes.txt");
	// 外来属性 [ attr, prefix, local_name ]
	auto foreign_attributes = read<std::vector<std::array<std::u32string, 3>>>(data_path / "foreign_attributes.txt");
	// 互換性モードテーブル
	auto quirks_mode = read(data_path / "quirks_mode.txt");
	// SVGタグ名
	auto svg_elements = read<std::vector<std::array<std::u32string, 2>>>(data_path / "svg_elements.txt");

	// 名前空間
	auto namespaces = read<std::vector<std::array<std::u32string, 2>>>(data_path / "namespaces.txt");

	// 名前指定文字参照表
	auto named_character_reference = read<std::vector<std::array<std::u32string, 3>>>(data_path / "named_character_reference.txt");
	// 文字参照コード変換表
	auto character_reference_code = read<std::vector<std::array<std::u32string, 2>>>(data_path / "character_reference_code.txt");

	// アトム集合を作成
	basic_atom_set<std::u32string> atom_tbl;
	{
		std::vector<std::u32string> v = elements;

		std::copy(attributes.begin(), attributes.end(), std::back_inserter(v));
		std::copy(events.begin(), events.end(), std::back_inserter(v));
		for (auto const& a : svg_attributes) v.push_back(a[0]);
		std::copy(mathml_attributes.begin(), mathml_attributes.end(), std::back_inserter(v));
		for (auto const& a : foreign_attributes) v.push_back(a[0]);
		for (auto const& a : svg_elements) v.push_back(a[0]);
		for (auto const& a : namespaces) v.push_back(a[0]);

		std::sort(v.begin(), v.end());
		v.erase(std::unique(v.begin(), v.end()), v.end());

		atom_tbl.assign(v.begin(), v.end());
	}

	// 名前指定文字参照表索引を作成
	wordring::trie<char32_t> named_character_reference_idx_tbl;
	std::vector<std::array<std::u32string, 2>> named_character_reference_map_tbl;
	{
		std::uint32_t i = 0;
		for (auto const& a : named_character_reference)
		{
			named_character_reference_idx_tbl.insert(a[0], i++);
			named_character_reference_map_tbl.push_back({ a[1], a[2] });
		}
	}

	// atom_tbl.hpp
	{
		std::ofstream hpp;
		hpp.open(atom_hpp_path, std::ios::out);
		assert(!hpp.fail());

		hpp << "#pragma once" << std::endl;
		hpp << "// generated by wordring_cpp/generator/whatwg/html/atom_tbl.cpp" << "" << std::endl;
		hpp << std::endl;
		hpp << "#include <wordring/string/atom.hpp>" << std::endl;
		hpp << "#include <wordring/trie/trie.hpp>" << std::endl;
		hpp << std::endl;
		hpp << "#include <array>" << std::endl;
		hpp << "#include <string>" << std::endl;
		hpp << "#include <unordered_map>" << std::endl;
		hpp << std::endl;
		hpp << "namespace wordring::whatwg::html::parsing" << std::endl;
		hpp << "{" << std::endl;

		// アトム表
		hpp << "\t" << "extern wordring::basic_atom_set<std::u32string> const atom_tbl;" << std::endl;
		hpp << std::endl;
		// 名前指定文字参照表
		hpp << "\t" << "extern wordring::trie<char32_t> const named_character_reference_idx_tbl;" << std::endl;
		hpp << "\t" << "extern std::array<std::array<char32_t, 2>, " << named_character_reference_map_tbl.size() << "> const named_character_reference_map_tbl;" << std::endl;
		hpp << std::endl;
		// 文字参照コード変換表
		hpp << "\t" << "extern std::unordered_map<char32_t, char32_t> const character_reference_code_tbl;" << std::endl;
		hpp << std::endl;
		// SVG属性変換表
		hpp << "\t" << "extern std::unordered_map<std::uint32_t, std::u32string> const adjust_svg_attribute_tbl;" << std::endl;
		hpp << std::endl;
		// 外来属性変換表
		hpp << "\t" << "extern std::unordered_map<std::uint32_t, std::array<std::u32string, 2>> const adjust_foreign_attribute_tbl;" << std::endl;
		hpp << std::endl;
		// 互換性モードテーブル
		hpp << "\t" << "extern wordring::trie<char32_t> const quirks_mode_tbl;" << std::endl;
		hpp << std::endl;
		// SVGタグ名変換表
		hpp << "\t" << "extern std::unordered_map<std::uint32_t, std::u32string> const svg_tag_name_tbl;" << std::endl;

		hpp << "}" << std::endl;
	}

	// atom_defs.hpp
	{
		using namespace wordring::whatwg;

		std::ofstream hpp;
		hpp.open(atom_defs_hpp_path, std::ios::out);
		assert(!hpp.fail());

		hpp << "#pragma once" << std::endl;
		hpp << "// generated by wordring_cpp/generator/whatwg/html/atom_tbl.cpp" << "" << std::endl;
		hpp << std::endl;
		hpp << "#include <cstdint>" << std::endl;
		hpp << std::endl;
		hpp << "namespace wordring::whatwg::html::parsing" << std::endl;
		hpp << "{" << std::endl;

		// 名前空間
		hpp << "\t" << "enum class namespaces : std::uint32_t" << std::endl;
		hpp << "\t" << "{" << std::endl;

		for (auto a : namespaces)
		{
			std::u32string label = a[0];
			auto atom = atom_tbl.at(label);
			hpp << "\t\t" <<  encoding_cast<std::string>(a[1]) << " = " << static_cast<std::uint32_t>(atom) << "," << std::endl;
		}

		// 

		hpp << "\t" << "};" << std::endl;
		hpp << "}" << std::endl;
	}

	// atom_tbl.cpp
	{
		std::ofstream cpp;
		cpp.open(atom_cpp_path, std::ios::out);
		assert(!cpp.fail());

		cpp << "// generated by wordring_cpp/generator/whatwg/html/atom_tbl.cpp" << "" << std::endl;
		cpp << std::endl;
		cpp << "#include <wordring/whatwg/html/parsing/atom_tbl.hpp>" << std::endl;
		cpp << std::endl;

		// アトム表
		cpp << "wordring::basic_atom_set<std::u32string> const wordring::whatwg::html::parsing::atom_tbl = {" << std::endl;
		auto it1 = atom_tbl.ibegin();
		auto it2 = atom_tbl.iend();
		std::uint32_t n = 0;
		for (std::uint32_t i = 0; it1 != it2; ++i)
		{
			++n;
			std::int32_t j = *it1++;
			if (n == 1) cpp << "\t";
			if (i % 2 == 0) cpp << "{ " << j << ", ";
			else cpp << j << " }, ";
			if (n == 20)
			{
				cpp << std::endl;
				n = 0;
			}
		}
		cpp << std::endl;
		cpp << "};" << std::endl;
		cpp << std::endl;

		// 名前指定文字参照表
		cpp << "wordring::trie<char32_t> const wordring::whatwg::html::parsing::named_character_reference_idx_tbl = {" << std::endl;
		auto it3 = named_character_reference_idx_tbl.ibegin();
		auto it4 = named_character_reference_idx_tbl.iend();
		n = 0;
		for (std::uint32_t i = 0; it3 != it4; ++i)
		{
			++n;
			std::int32_t j = *it3++;
			if (n == 1) cpp << "\t";
			if (i % 2 == 0) cpp << "{ " << j << ", ";
			else cpp << j << " }, ";
			if (n == 20)
			{
				cpp << std::endl;
				n = 0;
			}
		}
		cpp << std::endl;
		cpp << "};" << std::endl;
		cpp << std::endl;

		cpp << "std::array<std::array<char32_t, 2>, " << named_character_reference_map_tbl.size() << "> const wordring::whatwg::html::parsing::named_character_reference_map_tbl = {{" << std::endl;
		n = 0;
		for (std::array<std::u32string, 2> const& a : named_character_reference_map_tbl)
		{
			using namespace wordring::whatwg;
			++n;
			if (n == 1) cpp << "\t";
			cpp << "{ " << encoding_cast<std::string>(a[0]) << ", "
				<< (a[1].empty() ? "0" : encoding_cast<std::string>(a[1])) << " }, ";
			if (n == 10)
			{
				cpp << std::endl;
				n = 0;
			}
		}
		cpp << std::endl;
		cpp << "}};" << std::endl;
		cpp << std::endl;

		// 文字参照コード変換表
		cpp << "std::unordered_map<char32_t, char32_t> const wordring::whatwg::html::parsing::character_reference_code_tbl = {" << std::endl;
		n = 0;
		for (std::array<std::u32string, 2> const& a : character_reference_code)
		{
			using namespace wordring::whatwg;
			++n;
			if (n == 1) cpp << "\t";
			cpp << "{ " << encoding_cast<std::string>(a[0]) << ", " << encoding_cast<std::string>(a[1]) << " }, ";
			if (n == 10)
			{
				cpp << std::endl;
				n = 0;
			}
		}
		cpp << std::endl;
		cpp << "};" << std::endl;
		cpp << std::endl;

		// SVG属性変換表
		cpp << "std::unordered_map<uint32_t, std::u32string> const wordring::whatwg::html::parsing::adjust_svg_attribute_tbl = {" << std::endl;
		n = 0;
		for (std::array<std::u32string, 2> const& a : svg_attributes)
		{
			using namespace wordring::whatwg;
			auto atm = atom_tbl.at(a[0]);
			++n;
			if (n == 1) cpp << "\t";
			cpp << "{ " << static_cast<std::uint32_t>(atm) << ", U\"" << encoding_cast<std::string>(a[1]) << "\" }, ";
			if (n == 10)
			{
				cpp << std::endl;
				n = 0;
			}
		}
		cpp << std::endl;
		cpp << "};" << std::endl;
		cpp << std::endl;

		// 外来属性変換表
		cpp << "std::unordered_map<uint32_t, std::array<std::u32string, 2>> const wordring::whatwg::html::parsing::adjust_foreign_attribute_tbl = {" << std::endl;
		n = 0;
		for (std::array<std::u32string, 3> const& a : foreign_attributes)
		{
			using namespace wordring::whatwg;
			auto atm = atom_tbl.at(a[0]);
			++n;
			if (n == 1) cpp << "\t";
			cpp << "{ " << static_cast<std::uint32_t>(atm)
				<< ", { U\"" << encoding_cast<std::string>(a[1]) << "\", "
				<< "U\"" << encoding_cast<std::string>(a[2]) << "\" } }, ";
			if (n == 10)
			{
				cpp << std::endl;
				n = 0;
			}
		}
		cpp << std::endl;
		cpp << "};" << std::endl;
		cpp << std::endl;

		// 互換性モードテーブル
		cpp << "wordring::trie<char32_t> const wordring::whatwg::html::parsing::quirks_mode_tbl = {" << std::endl;
		std::sort(quirks_mode.begin(), quirks_mode.end());
		quirks_mode.erase(std::unique(quirks_mode.begin(), quirks_mode.end()), quirks_mode.end());
		auto quirks_mode_tbl = wordring::trie<char32_t>(quirks_mode.begin(), quirks_mode.end());
		auto it5 = quirks_mode_tbl.ibegin();
		auto it6 = quirks_mode_tbl.iend();
		n = 0;
		for (std::uint32_t i = 0; it5 != it6; ++i)
		{
			++n;
			std::int32_t j = *it5++;
			if (n == 1) cpp << "\t";
			if (i % 2 == 0) cpp << "{ " << j << ", ";
			else cpp << j << " }, ";
			if (n == 20)
			{
				cpp << std::endl;
				n = 0;
			}
		}
		cpp << std::endl;
		cpp << "};" << std::endl;
		cpp << std::endl;

		// SVGタグ名変換表
		cpp << "std::unordered_map<uint32_t, std::u32string> const wordring::whatwg::html::parsing::svg_tag_name_tbl = {" << std::endl;
		n = 0;
		for (std::array<std::u32string, 2> const& a : svg_elements)
		{
			using namespace wordring::whatwg;
			auto atm = atom_tbl.at(a[0]);
			++n;
			if (n == 1) cpp << "\t";
			cpp << "{ " << static_cast<std::uint32_t>(atm) << ", U\"" << encoding_cast<std::string>(a[1]) << "\" }, ";
			if (n == 10)
			{
				cpp << std::endl;
				n = 0;
			}
		}
		cpp << std::endl;
		cpp << "};" << std::endl;
	}

	return 0;
}
